<!--
Unibet × Polymarket Arb Scanner

How to use:
1) Deploy the Cloudflare Worker (code below this file; search for "===== Cloudflare Worker (copy to worker.js) =====").
2) In index.html, set WORKER_BASE to your Worker URL (e.g. https://your-subdomain.workers.dev).
3) Commit to a GitHub repo and enable GitHub Pages (main branch / root).

What it does:
- Pulls Polymarket prices for "Super Bowl Champion 2026" via the Gamma + CLOB APIs.
- Pulls Unibet (France) NFL outright odds via Kambi JSON feeds (brand code: ubfr).
- Auto-matches teams and highlights two arbs: backing at Unibet & hedging by (A) Buy NO or (B) Sell YES on Polymarket.
- Shows: Total bet at Unibet, Total received from Polymarket, Total Return (currency), and Total Return %.

Notes:
- If Kambi paths change for Unibet, open DevTools > Network on unibet.fr page and look for requests to
  eu1.offering-api.kambicdn.com or eu-offering.kambicdn.com with path /offering/v2018/ubfr/listView/american_football/nfl/...
  Copy a working URL into the WORKER_KAMBI_URL in your worker (fallbacks included already).
- Polymarket event slug can be changed via CONFIG.polymarket.eventSlug below.
- Negative-risk (winner-take-all) is handled; the app computes both Buy NO & Sell YES thresholds.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unibet × Polymarket Arb Scanner</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { --ok: #16a34a; --bad: #b91c1c; --muted:#6b7280; }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .pill { display:inline-flex; align-items:center; justify-content:center; border-radius:9999px; padding:0.25rem 0.625rem; font-size:0.75rem; font-weight:600; }
    .shadow-soft { box-shadow: 0 10px 20px rgba(0,0,0,.05); }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" on, "lnum" on; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-6xl mx-auto p-4 sm:p-6">
    <header class="flex items-start justify-between gap-4 mb-6">
      <div>
        <h1 class="text-2xl sm:text-3xl font-bold">Unibet × Polymarket Arb Scanner</h1>
        <p class="text-sm text-gray-600">Super Bowl LX (2026) — backs at Unibet, hedge on Polymarket.</p>
      </div>
      <div class="flex items-center gap-2">
        <button id="refreshBtn" class="px-4 py-2 rounded-xl bg-black text-white font-semibold shadow-soft">Refresh</button>
      </div>
    </header>

    <section class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-6">
      <div class="bg-white rounded-2xl p-4 sm:p-5 shadow-soft">
        <h2 class="font-semibold mb-3">Inputs</h2>
        <div class="grid grid-cols-2 gap-3">
          <label class="flex flex-col gap-1">
            <span class="text-sm text-gray-600">Stake per team</span>
            <input id="stakeInput" type="number" step="1" min="1" value="100" class="rounded-xl border px-3 py-2 mono" />
          </label>
          <label class="flex flex-col gap-1">
            <span class="text-sm text-gray-600">Currency</span>
            <select id="ccy" class="rounded-xl border px-3 py-2">
              <option value="EUR">EUR</option>
              <option value="USD">USD</option>
              <option value="GBP">GBP</option>
            </select>
          </label>
          <label class="flex items-center gap-2 col-span-2">
            <input id="useFees" type="checkbox" class="w-4 h-4" />
            <span class="text-sm">Apply Polymarket fee on net winnings</span>
          </label>
          <label class="flex flex-col gap-1">
            <span class="text-sm text-gray-600">PM fee %</span>
            <input id="feePct" type="number" step="0.1" value="0" class="rounded-xl border px-3 py-2 mono" />
          </label>
          <label class="flex flex-col gap-1">
            <span class="text-sm text-gray-600">Hedge mode</span>
            <select id="hedgeMode" class="rounded-xl border px-3 py-2">
              <option value="best">Best of (Buy NO vs Sell YES)</option>
              <option value="buyNO">Buy NO only</option>
              <option value="sellYES">Sell YES only</option>
            </select>
          </label>
        </div>
      </div>

      <div class="bg-white rounded-2xl p-4 sm:p-5 shadow-soft">
        <h2 class="font-semibold mb-3">Data status</h2>
        <div class="text-sm space-y-2">
          <div>Unibet (Kambi): <span id="unibetStatus" class="pill bg-gray-100 text-gray-700">…</span></div>
          <div>Polymarket: <span id="polyStatus" class="pill bg-gray-100 text-gray-700">…</span></div>
          <p class="text-xs text-gray-500">If Unibet fails, open DevTools → Network on their page and copy a working Kambi JSON URL into your Worker (see code below).</p>
        </div>
      </div>

      <div class="bg-white rounded-2xl p-4 sm:p-5 shadow-soft">
        <h2 class="font-semibold mb-3">Filters</h2>
        <div class="grid grid-cols-2 gap-3 text-sm">
          <label class="flex flex-col gap-1 col-span-2">
            <span class="text-sm text-gray-600">Search teams</span>
            <input id="search" placeholder="Type to filter…" class="rounded-xl border px-3 py-2" />
          </label>
          <label class="flex items-center gap-2 col-span-2">
            <input id="onlyArbs" type="checkbox" class="w-4 h-4" />
            <span>Show arbs only</span>
          </label>
        </div>
      </div>
    </section>

    <section class="bg-white rounded-2xl p-3 sm:p-5 shadow-soft">
      <div class="flex items-center justify-between">
        <h2 class="font-semibold mb-3">Opportunities</h2>
        <button id="exportBtn" class="px-3 py-1.5 rounded-xl border text-sm">Export CSV</button>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead class="text-left text-xs uppercase text-gray-500 border-b">
            <tr>
              <th class="py-2 pr-3">Team</th>
              <th class="py-2 pr-3">Unibet (Dec)</th>
              <th class="py-2 pr-3">PM Sell YES Bid</th>
              <th class="py-2 pr-3">PM Buy NO Ask</th>
              <th class="py-2 pr-3">Dmin (Sell YES)</th>
              <th class="py-2 pr-3">Dmin (Buy NO)</th>
              <th class="py-2 pr-3">Arb via</th>
              <th class="py-2 pr-3">Total bet (Unibet)</th>
              <th class="py-2 pr-3">Total received (PM)</th>
              <th class="py-2 pr-3">Total return</th>
              <th class="py-2 pr-3">Total return %</th>
            </tr>
          </thead>
          <tbody id="rows" class="divide-y"></tbody>
        </table>
      </div>
    </section>

    <footer class="text-xs text-gray-500 mt-6">Built for personal analysis. Check fees, limits, and local regulations. Markets move; verify before trading.</footer>
  </div>

  <script>
  // ====== CONFIG ======
  const WORKER_BASE = "https://YOUR-WORKER-SUBDOMAIN.workers.dev"; // ← change after deploying the worker
  const CONFIG = {
    polymarket: { eventSlug: "super-bowl-champion-2026-731" },
    unibet: { brand: "ubfr" }
  };

  // Team name mapping (Polymarket label -> Unibet team label)
  const TEAM_MAP = {
    "Baltimore": "Baltimore Ravens",
    "Buffalo": "Buffalo Bills",
    "Philadelphia": "Philadelphia Eagles",
    "Kansas City": "Kansas City Chiefs",
    "Green Bay": "Green Bay Packers",
    "Detroit": "Detroit Lions",
    "San Francisco": "San Francisco 49ers",
    "Cincinnati": "Cincinnati Bengals",
    "Washington": "Washington Commanders",
    "Los Angeles Rams": "Los Angeles Rams",
    "LA Rams": "Los Angeles Rams",
    "Minnesota": "Minnesota Vikings",
    "Pittsburgh": "Pittsburgh Steelers",
    "Dallas": "Dallas Cowboys",
    "Miami": "Miami Dolphins",
    "New York Jets": "New York Jets",
    "NY Jets": "New York Jets",
    "New York Giants": "New York Giants",
    "NY Giants": "New York Giants",
    "New England": "New England Patriots",
    "Cleveland": "Cleveland Browns",
    "Chicago": "Chicago Bears",
    "Atlanta": "Atlanta Falcons",
    "Tampa Bay": "Tampa Bay Buccaneers",
    "Jacksonville": "Jacksonville Jaguars",
    "Tennessee": "Tennessee Titans",
    "Carolina": "Carolina Panthers",
    "Houston": "Houston Texans",
    "Indianapolis": "Indianapolis Colts",
    "Las Vegas": "Las Vegas Raiders",
    "LA Chargers": "Los Angeles Chargers",
    "Los Angeles Chargers": "Los Angeles Chargers",
    "Denver": "Denver Broncos",
    "Arizona": "Arizona Cardinals",
    "Seattle": "Seattle Seahawks",
    "New Orleans": "New Orleans Saints"
  };

  const el = (id) => document.getElementById(id);
  const fmt = (x, d=2) => (x===null||x===undefined||isNaN(x)) ? "–" : Number(x).toFixed(d);

  function unify(str){
    return str.toLowerCase().replace(/[^a-z0-9]/g, "").replace(/the/g, "");
  }

  function matchTeam(polyName, unibetMap){
    const guess = TEAM_MAP[polyName] || polyName;
    const k = unify(guess);
    if(unibetMap[k]) return unibetMap[k];
    // Fallback: try contains
    for(const key in unibetMap){
      if(key.includes(unify(polyName)) || unify(polyName).includes(key)) return unibetMap[key];
    }
    return null;
  }

  function dMinSellYES(pYesBid, fee=0){
    // threshold D >= 1 / p, adjusted for fee on sportsbook profit via PM? We'll conservatively apply fee to PM side only.
    if(!pYesBid) return null;
    const p = Math.max(1e-6, pYesBid);
    return 1 / (p - 0); // fee applied later in PnL
  }
  function dMinBuyNO(qNoAsk){
    if(!qNoAsk && qNoAsk!==0) return null;
    const q = Math.min(0.999999, Math.max(0, qNoAsk));
    return 1 / (1 - q);
  }

  function calcPnL({stake, D, pYesBid, qNoAsk, mode, feePct}){
    // Returns {arb:false/true, via:"sellYES"|"buyNO"|null, betUnibet, pmReceived, totalReturn, totalReturnPct}
    const f = (mode==="sellYES") ? (D >= dMinSellYES(pYesBid)) : (D >= dMinBuyNO(qNoAsk));
    if(!f) return {arb:false};
    if(mode === "sellYES"){
      // Choose m shares so m = S*D
      const m = stake * D;
      const pmCashIn = pYesBid * m;   // received now
      // Settlement worst-case occurs when team loses or wins? Profit equalization yields constant profit S*(p*D - 1)
      let profit = stake * (pYesBid * D - 1);
      if(feePct>0){
        // Apply fee on positive PM leg only (payout). In sellYES, when the team loses, PM realizes +p*m (we received p now).
        // The equalized profit comes half from PM in the lose branch; approximate fee hit on PM positive leg portion.
        const pmPos = pYesBid * m; // positive leg when team loses
        profit -= (feePct/100) * pmPos; 
      }
      const totalReturn = profit; // currency units
      const totalReturnPct = (profit / stake) * 100;
      return {arb:true, via:"sellYES", betUnibet: stake, pmReceived: pmCashIn, totalReturn, totalReturnPct};
    } else {
      // buy NO: n = S*D
      const n = stake * D;
      const pmCashOut = qNoAsk * n; // spent
      let profit = stake * (D * (1 - qNoAsk) - 1);
      if(feePct>0){
        // Fee on PM positive leg (when team loses, NO pays 1 per share). Positive PM inflow is n*(1-q)
        const pmPos = n * (1 - qNoAsk);
        profit -= (feePct/100) * pmPos;
      }
      return {arb:true, via:"buyNO", betUnibet: stake, pmReceived: -pmCashOut, totalReturn: profit, totalReturnPct: (profit/stake)*100 };
    }
  }

  async function fetchAll(){
    const stake = parseFloat(el("stakeInput").value || "100");
    const feePct = el("useFees").checked ? parseFloat(el("feePct").value || "0") : 0;
    const modeSel = el("hedgeMode").value; // best | buyNO | sellYES

    el("unibetStatus").textContent = "loading…";
    el("polyStatus").textContent = "loading…";

    const [unibetRes, polyRes] = await Promise.allSettled([
      fetch(`${WORKER_BASE}/unibet-nfl-futures?brand=${CONFIG.unibet.brand}`),
      fetch(`${WORKER_BASE}/polymarket-superbowl?slug=${CONFIG.polymarket.eventSlug}`)
    ]);

    let unibetMap = {};
    if(unibetRes.status === "fulfilled" && unibetRes.value.ok){
      const u = await unibetRes.value.json();
      // u = [{team:"Buffalo Bills", oddsDec: 8.0}, ...]
      u.forEach(r => unibetMap[unify(r.team)] = r);
      el("unibetStatus").textContent = `ok (${u.length} teams)`;
      el("unibetStatus").className = "pill bg-green-100 text-green-700";
    } else {
      el("unibetStatus").textContent = "error";
      el("unibetStatus").className = "pill bg-red-100 text-red-700";
    }

    let poly = [];
    if(polyRes.status === "fulfilled" && polyRes.value.ok){
      poly = await polyRes.value.json();
      el("polyStatus").textContent = `ok (${poly.length} markets)`;
      el("polyStatus").className = "pill bg-green-100 text-green-700";
    } else {
      el("polyStatus").textContent = "error";
      el("polyStatus").className = "pill bg-red-100 text-red-700";
    }

    const rowsEl = el("rows");
    rowsEl.innerHTML = "";

    const search = el("search").value.trim().toLowerCase();
    const onlyArbs = el("onlyArbs").checked;
    const ccy = el("ccy").value || "EUR";

    // Build table rows
    let rows = [];
    for(const m of poly){
      const match = matchTeam(m.team, unibetMap);
      if(!match) continue;
      const D = match.oddsDec;
      const pBid = m.yesBid; // price you can sell YES at
      const qAsk = m.noAsk;  // price to buy NO
      const sellThresh = dMinSellYES(pBid);
      const buyThresh  = dMinBuyNO(qAsk);

      let best = null;
      if(modeSel === "best"){
        const sell = calcPnL({stake, D, pYesBid:pBid, qNoAsk:qAsk, mode:"sellYES", feePct});
        const buy  = calcPnL({stake, D, pYesBid:pBid, qNoAsk:qAsk, mode:"buyNO",  feePct});
        if(sell.arb && buy.arb){ best = (sell.totalReturn > buy.totalReturn) ? sell : buy; }
        else best = sell.arb ? sell : (buy.arb ? buy : {arb:false});
      } else if(modeSel === "sellYES") {
        best = calcPnL({stake, D, pYesBid:pBid, qNoAsk:qAsk, mode:"sellYES", feePct});
      } else {
        best = calcPnL({stake, D, pYesBid:pBid, qNoAsk:qAsk, mode:"buyNO", feePct});
      }

      const isArb = !!best.arb;
      const via = best.via || "—";
      const style = isArb ? "bg-green-50" : "";
      const retPct = isArb ? fmt(best.totalReturnPct, 2) + "%" : "–";
      const retAmt = isArb ? `${ccy} ${fmt(best.totalReturn, 2)}` : "–";
      const betAmt = isArb ? `${ccy} ${fmt(best.betUnibet, 2)}` : `${ccy} ${fmt(stake,2)}`;
      const pmAmt  = isArb ? `${ccy} ${fmt(best.pmReceived, 2)}` : "–";

      const name = `${m.team}`;
      if(search && !name.toLowerCase().includes(search) && !match.team.toLowerCase().includes(search)) continue;
      if(onlyArbs && !isArb) continue;

      rows.push({
        key: name,
        html: `<tr class="${style}">
          <td class="py-2 pr-3">${name}</td>
          <td class="py-2 pr-3 mono">${fmt(D,2)}</td>
          <td class="py-2 pr-3 mono">${fmt(pBid,3)}</td>
          <td class="py-2 pr-3 mono">${fmt(qAsk,3)}</td>
          <td class="py-2 pr-3 mono">${sellThresh?fmt(sellThresh,2):"–"}</td>
          <td class="py-2 pr-3 mono">${buyThresh?fmt(buyThresh,2):"–"}</td>
          <td class="py-2 pr-3">${isArb ? (via==="sellYES"?"Sell YES":"Buy NO") : "–"}</td>
          <td class="py-2 pr-3 mono">${betAmt}</td>
          <td class="py-2 pr-3 mono">${pmAmt}</td>
          <td class="py-2 pr-3 mono font-semibold">${retAmt}</td>
          <td class="py-2 pr-3 mono font-semibold">${retPct}</td>
        </tr>`
      });
    }

    // sort by total return desc
    rows.sort((a,b)=>{
      const x = /([-\d.]+)/.exec(a.html)?.[1];
      const y = /([-\d.]+)/.exec(b.html)?.[1];
      return (parseFloat(y||"0") - parseFloat(x||"0"));
    });

    rowsEl.innerHTML = rows.map(r=>r.html).join("");
  }

  function exportCSV(){
    const headers = ["Team","UnibetDec","PM_SellYES_Bid","PM_BuyNO_Ask","Dmin_SellYES","Dmin_BuyNO","ArbVia","BetUnibet","PMReceived","TotalReturn","TotalReturnPct"];
    const rows = Array.from(document.querySelectorAll('#rows tr')).map(tr => Array.from(tr.querySelectorAll('td')).map(td=>td.innerText.replace(/[,]/g,'')) );
    const data = [headers, ...rows];
    const csv = data.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'arb_scanner.csv'; a.click();
    URL.revokeObjectURL(url);
  }

  // Events
  ["stakeInput","feePct","useFees","hedgeMode","search","onlyArbs","ccy"].forEach(id=>{
    document.getElementById(id).addEventListener('input', ()=> fetchAll());
    document.getElementById(id).addEventListener('change', ()=> fetchAll());
  });
  document.getElementById('refreshBtn').addEventListener('click', fetchAll);
  document.getElementById('exportBtn').addEventListener('click', exportCSV);

  // Kickoff
  fetchAll();
  </script>
</body>
</html>


<!-- ===== Cloudflare Worker (copy to worker.js) =====
Deploy: wrangler init && wrangler deploy
Set no secrets needed. Ensure CORS is open for your GitHub Pages domain.
-->

/*
 * Cloudflare Worker: Aggregates Unibet (Kambi) & Polymarket data into clean JSON.
 * Routes:
 *  - GET /polymarket-superbowl?slug=super-bowl-champion-2026-731
 *  - GET /unibet-nfl-futures?brand=ubfr
 */
export default {
  async fetch(req, env, ctx) {
    try {
      const url = new URL(req.url);
      const path = url.pathname;
      if (path === '/polymarket-superbowl') return polyHandler(url);
      if (path === '/unibet-nfl-futures') return unibetHandler(url);
      return json({ ok: true, message: 'Worker live. Use /polymarket-superbowl and /unibet-nfl-futures' });
    } catch (e) {
      return json({ error: e.message }, 500);
    }
  }
}

function json(body, status=200, hdr={}){
  return new Response(JSON.stringify(body), {
    status,
    headers: { 'content-type': 'application/json', 'access-control-allow-origin': '*', ...hdr }
  });
}

async function polyHandler(url){
  const slug = url.searchParams.get('slug') || 'super-bowl-champion-2026-731';
  // 1) Fetch event + markets from Gamma API
  const ev = await fetch(`https://gamma-api.polymarket.com/events?slug=${encodeURIComponent(slug)}`);
  if(!ev.ok) return json({ error: 'Gamma events fetch failed', status: ev.status }, ev.status);
  const events = await ev.json();
  const event = Array.isArray(events) ? events[0] : (events?.[0] || events?.data?.[0] || events);
  if(!event || !event.markets) return json([]);

  // Extract token IDs & slugs for YES/NO for each team market
  const mkts = event.markets.map(m=>({
    question: m.question || m.marketTitle || m.title || '',
    slug: m.slug,
    clobTokenIds: m.clob_token_ids || m.clobTokenIds || m.tokens || m.outcomeTokenIds || [],
    outcomes: m.outcomes || m.shortOutcomes || ['Yes','No'],
  }));

  // Normalize to { team, yesToken, noToken }
  const norm = mkts.map(m=>{
    let yesToken=null, noToken=null;
    if(Array.isArray(m.clobTokenIds) && m.clobTokenIds.length>=2){
      // Assume [YES, NO]
      yesToken = m.clobTokenIds[0];
      noToken  = m.clobTokenIds[1];
    }
    // Team name: strip "Will the X win Super Bowl ..." → "X"
    let team = m.question.replace(/Will (the )?/i,'').replace(/win the.*$/i,'').replace(/win .*$/i,'').replace(/\?$/,'').trim();
    team = team.replace(/^the /i,'').replace(/\s+\(.*\)$/,'').trim();
    return { team, slug: m.slug, yesToken, noToken };
  });

  // 2) Get best bid/ask for YES & NO via CLOB prices endpoint (public)
  const priceReq = [];
  const idSet = new Set();
  for(const r of norm){ if(r.yesToken){ idSet.add(r.yesToken); } if(r.noToken){ idSet.add(r.noToken);} }
  const ids = Array.from(idSet);
  let books = {};
  if(ids.length){
    // Fetch best bids
    const bids = await fetch('https://clob.polymarket.com/prices', {
      method: 'POST', headers: {'content-type':'application/json'},
      body: JSON.stringify({ params: ids.map(t=>({ token_id: t, side:'SELL' })) }) // SELL side => best bid (what you can hit when selling)
    });
    const bidsJson = bids.ok ? await bids.json() : {};
    const asks = await fetch('https://clob.polymarket.com/prices', {
      method: 'POST', headers: {'content-type':'application/json'},
      body: JSON.stringify({ params: ids.map(t=>({ token_id: t, side:'BUY' })) }) // BUY side => best ask (what you pay when buying)
    });
    const asksJson = asks.ok ? await asks.json() : {};
    // Map token -> {bid, ask}
    for(const p of (bidsJson?.prices||[])){
      books[p.token_id] = { bid: Number(p.price) };
    }
    for(const p of (asksJson?.prices||[])){
      books[p.token_id] = { ...(books[p.token_id]||{}), ask: Number(p.price) };
    }
  }

  // Build final records
  const out = norm.map(r=>({
    team: r.team,
    yesBid: r.yesToken ? (books[r.yesToken]?.bid ?? null) : null,
    yesAsk: r.yesToken ? (books[r.yesToken]?.ask ?? null) : null,
    noBid:  r.noToken  ? (books[r.noToken]?.bid  ?? null) : null,
    noAsk:  r.noToken  ? (books[r.noToken]?.ask  ?? null) : null,
    slug: r.slug,
    yesToken: r.yesToken || null,
    noToken: r.noToken || null,
  })).filter(r=>r.team);

  return json(out);
}

async function unibetHandler(url){
  const brand = url.searchParams.get('brand') || 'ubfr';
  // Try multiple Kambi listView endpoints; pick first working
  const baseCandidates = [
    `https://eu1.offering-api.kambicdn.com/offering/v2018/${brand}`,
    `https://eu-offering.kambicdn.com/offering/v2018/${brand}`
  ];
  let data = null, used = null;
  for(const base of baseCandidates){
    const u = `${base}/listView/american_football/nfl/all/all/competitions.json?lang=fr_FR&market=FR&client_id=2&channel_id=1&useCombined=true&useCombinedLive=true`;
    const res = await fetch(u);
    if(res.ok){ data = await res.json(); used = u; break; }
  }
  if(!data){
    return json({ error: 'Kambi competitions fetch failed' }, 502);
  }
  // Find the competition/group that contains Super Bowl Winner (Vainqueur)
  let compId = null;
  // Heuristic scan
  const comps = data?.competitions || data?.events || data?.path || [];
  const text = JSON.stringify(data).toLowerCase();
  const rx = /(super\s*bowl|vainqueur|winner)/i;
  if(rx.test(text)){
    // Attempt to locate a competitionId field
    const ids = (text.match(/"competitionId"\s*:\s*([0-9]+)/g)||[]).map(s=>Number(s.replace(/[^0-9]/g,'')));
    compId = ids?.[0] || null;
  }
  // Fallback: try known outright endpoint type (competition JSON)
  let offers = [];
  if(compId){
    for(const base of baseCandidates){
      const u = `${base}/betoffer/competition/${compId}.json?lang=fr_FR&market=FR&client_id=2&channel_id=1`;
      const r = await fetch(u);
      if(r.ok){ const j = await r.json(); offers = j?.betOffers || j?.offers || []; if(offers.length){ break; } }
    }
  }
  // If still empty, try direct outrights listView
  if(!offers.length){
    for(const base of baseCandidates){
      const u = `${base}/listView/american_football/nfl/all/all/outrights.json?lang=fr_FR&market=FR&client_id=2&channel_id=1&useCombined=true`;
      const r = await fetch(u); if(r.ok){ const j = await r.json(); offers = j?.betOffers || j?.offers || []; if(offers.length){ break; } }
    }
  }

  // Flatten outcomes → {team, oddsDec}
  const rows = [];
  const pushOutcome = (name, oddsObj)=>{
    if(!name || !oddsObj) return;
    const team = String(name).replace(/\(.*?\)/g,'').trim();
    let dec = null;
    if(typeof oddsObj.american === 'number' && typeof oddsObj.decimal === 'number') dec = oddsObj.decimal;
    if(oddsObj?.decimalOdds) dec = Number(oddsObj.decimalOdds);
    if(oddsObj?.decimal) dec = Number(oddsObj.decimal);
    if(oddsObj?.oddsDecimal) dec = Number(oddsObj.oddsDecimal);
    if(dec){ rows.push({ team, oddsDec: dec }); }
  };

  for(const bo of offers){
    const marketName = (bo?.criterion?.label || bo?.market?.name || bo?.event?.name || '').toLowerCase();
    if(/(vainqueur|winner|super\s*bowl)/i.test(marketName) || rows.length===0){
      const outcomes = bo?.outcomes || bo?.participants || bo?.selections || [];
      for(const o of outcomes){
        const name = o?.label || o?.name || o?.participant || o?.competitor || o?.outcome;
        const odds = o?.odds || o?.price || o?.oddsAmerican || o?.oddsDecimal ? o : o?.odds;
        // Kambi outcome shape often: { label, odds: { decimal: 8.00, fractional:"7/1", american:+700 } }
        const oddsObj = odds?.odds ? odds.odds : odds;
        pushOutcome(name, oddsObj);
      }
    }
  }

  // De-duplicate by team (keep best odds)
  const map = new Map();
  for(const r of rows){
    const k = r.team.toLowerCase();
    if(!map.has(k) || (map.get(k).oddsDec < r.oddsDec)) map.set(k, r);
  }
  const out = Array.from(map.values());
  return json(out);
}
